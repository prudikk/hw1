Сұрақта “Магиялық әдістер қандай жағдайда қолданылады?” деп сұралған.

Дұрыс жауап:
“Python-ның арнайы операцияларын қайта анықтау үшін”
Python-да инкапсуляцияны жүзеге асыру жолдары:

✅ Private атрибуттарды __ арқылы белгілеу
— Python-да екі астын сызу (__private_attr) арқылы атрибутты “private” етіп белгілеуге болады.

✅ Getter және setter әдістерін қолдану
— get_ және set_ әдістерін қолданып, атрибуттарға қолжетімділікті реттеуге болады.

✅ property декораторын пайдалану
— @property декораторы арқылы getter және setter әдістерін анықтап, атрибутқа қолжетімділікті басқара аламыз.
Duck typing-тің негізгі ерекшеліктері:

✅ Объектінің нақты класын тексерудің қажеті жоқ
— Duck typing-де объектінің нақты класы маңызды емес, тек оның қолданылатын әдістері мен қасиеттері маңызды.

✅ Python-ның динамикалық типтеу жүйесіне негізделген
— Python статикалық типтелген тіл емес, сондықтан duck typing динамикалық типтеуді қолданады.

✅ Егер объект quack() әдісін шақыра алса, ол “үйрек” ретінде қарастырылады
— “If it looks like a duck and quacks like a duck, it must be a duck” принципіне негізделген.
Объектіге бағытталған бағдарламалауда инкапсуляция дегеніміз:

✅ Деректерді және олармен жұмыс істейтін әдістерді біртұтас компонентке орау механизмі
— Инкапсуляция дегеніміз — деректер мен оларды өңдейтін әдістерді бір класта біріктіру, сыртқы қолжетімділікті шектеу.

✅ Нысанның сыртқы араласудан өзінің ішкі күйлерін жасыру мүмкіндігі
— Инкапсуляция объектінің ішкі күйін сыртқы қолданушылардан қорғауға мүмкіндік береді, бұл деректерді қауіпсіз ету үшін қажет.
Абстракт кластың объектісін тікелей жасауға бола ма?
✅ Жоқ, болмайды
Duck typing дегеніміз не?

✅ Дұрыс жауап:
“Объектілік жүйелеу жүйесінде, объектілердің түрлері олардың сыныптары арқылы емес, қолданатын әдістері мен қасиеттері арқылы анықталады.”
Сұрақ: Полиморфизм объектілердің қандай артықшылықтарын береді? Егер make_sound() функциясы speak() әдісі жоқ объектіге қолданылса, не болады? 
Гав!
Мяу!
Чик-чирик!
Python класс объектісі үшін len() функциясы қолданылған кезде қандай магиялық әдіс қолданылады?

Жауап:

Дұрыс жауап: _len_()
Python-дағы абстракт кластар қандай жағдайларда қолданылады? Абстракт класс жазып, оны мұрагерлік ететін туынды класс құрыңыз.

Қосымша сұрақтар:
	1.	Абстракт кластарды қолданудың қандай артықшылықтары бар?
	2.	Егер туынды класс абстракт әдістерді қайта анықтамаса, не болады?
Абстракт кластарды қолдану:

Абстракт кластар интерфейс ретінде қолданылады, яғни олар белгілі бір әдістерді міндетті түрде қайта анықтауды талап етеді. Бұл мұрагерлік принципін дұрыс ұйымдастыруға көмектеседі.

Python-да абстракт класты жасау үшін ABC (Abstract Base Class) модулін қолданамыз.
Кодтың нәтижесін болжау және қатені түзету жолы

Берілген код:

class BankAccount:
    def _init_(self, owner, balance):
        self.owner = owner
        self.__balance = balance  # Инкапсуляцияланған баланс

    def deposit(self, amount):
        self.__balance += amount

    def withdraw(self, amount):
        if amount <= self.__balance:
            self.__balance -= amount
            return amount
        return "Қаражат жеткіліксіз!"

account = BankAccount("Айгүл", 100000)
print(account.__balance)  # Нәтиже қандай?

Қате және оны түзету жолы:

Берілген кодта инкапсуляция (private member) қағидасы қолданылған. self._balance айнымалысы екі төменгі сызық (balance) арқылы жеке (private) болып анықталған. Сондықтан, print(account._balance) қатеге әкеледі, өйткені __balance айнымалысына тікелей қолжеткізуге болмайды.

Қатенің нәтижесі:

AttributeError: 'BankAccount' object has no attribute '__balance'

Инкапсуляцияны бұзбай __balance мәніне қол жеткізу жолы:
	1.	Геттер (getter) әдісін қолдану:

class BankAccount:
    def _init_(self, owner, balance):
        self.owner = owner
        self.__balance = balance

    def deposit(self, amount):
        self.__balance += amount

    def withdraw(self, amount):
        if amount <= self.__balance:
            self.__balance -= amount
            return amount
        return "Қаражат жеткіліксіз!"

    # Геттер әдісі
    def get_balance(self):
        return self.__balance

account = BankAccount("Айгүл", 100000)
print(account.get_balance())  # Нәтиже: 100000


	2.	Проперти (property) әдісін қолдану:

class BankAccount:
    def _init_(self, owner, balance):
        self.owner = owner
        self.__balance = balance

    @property
    def balance(self):
        return self.__balance

account = BankAccount("Айгүл", 100000)
print(account.balance)  # Нәтиже: 100000



Бұл тәсілдер инкапсуляция қағидасын сақтай отырып, __balance мәнін алу мүмкіндігін береді.
Сұрақ: Объекті-бағдарланған бағдарламалауда инкапсуляция концепциясын ең дәл қайсы анықтама бейнелейді?

Дұрыс жауап:

✅ “Объектің жеке деректері мен әдістерінің жасырын және қауіпсіздік мақсатында сырттан қолжетімсіз болуы”
Сұрақ: Қайсысы келесі принциптердің ішінен объекті-бағдарламалық жасауда инкапсуляциямен ең аз байланысты?

Дұрыс жауап:

✅ “Многопоточность Көп арналылық”